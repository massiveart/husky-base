<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>/Users/marcelmoosbrugger/Development/husky-base/src/components/core/datagrid/decorators/table-view.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AutoComplete.html">AutoComplete</a></li>
            
                <li><a href="../classes/AutoCompleteList.html">AutoCompleteList</a></li>
            
                <li><a href="../classes/base.html">base</a></li>
            
                <li><a href="../classes/CKEditor.html">CKEditor</a></li>
            
                <li><a href="../classes/Column-Options.html">Column-Options</a></li>
            
                <li><a href="../classes/ColumnNavigation.html">ColumnNavigation</a></li>
            
                <li><a href="../classes/Component.html">Component</a></li>
            
                <li><a href="../classes/DataGrid.html">DataGrid</a></li>
            
                <li><a href="../classes/Dependant Select.html">Dependant Select</a></li>
            
                <li><a href="../classes/DropdownPagination (Datagrid Decorator).html">DropdownPagination (Datagrid Decorator)</a></li>
            
                <li><a href="../classes/Dropzone.html">Dropzone</a></li>
            
                <li><a href="../classes/ExtensionManager.html">ExtensionManager</a></li>
            
                <li><a href="../classes/Husky.html">Husky</a></li>
            
                <li><a href="../classes/Label.html">Label</a></li>
            
                <li><a href="../classes/Loader.html">Loader</a></li>
            
                <li><a href="../classes/Logger.html">Logger</a></li>
            
                <li><a href="../classes/Overlay.html">Overlay</a></li>
            
                <li><a href="../classes/Sandbox.html">Sandbox</a></li>
            
                <li><a href="../classes/Search.html">Search</a></li>
            
                <li><a href="../classes/Select.html">Select</a></li>
            
                <li><a href="../classes/ShowAllPagination (Datagrid Decorator).html">ShowAllPagination (Datagrid Decorator)</a></li>
            
                <li><a href="../classes/TableView (Datagrid Decorator).html">TableView (Datagrid Decorator)</a></li>
            
                <li><a href="../classes/Tabs.html">Tabs</a></li>
            
                <li><a href="../classes/ThumbnailView (Datagrid Decorator).html">ThumbnailView (Datagrid Decorator)</a></li>
            
                <li><a href="../classes/Toggler.html">Toggler</a></li>
            
                <li><a href="../classes/Toolbar.html">Toolbar</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/husky.html">husky</a></li>
            
                <li><a href="../modules/husky_components.html">husky/components</a></li>
            
                <li><a href="../modules/husky_components_auto-complete.html">husky/components/auto-complete</a></li>
            
                <li><a href="../modules/husky_components_auto-complete-list.html">husky/components/auto-complete-list</a></li>
            
                <li><a href="../modules/husky_components_column-navigation.html">husky/components/column-navigation</a></li>
            
                <li><a href="../modules/husky_components_column-options.html">husky/components/column-options</a></li>
            
                <li><a href="../modules/husky_components_dropzone.html">husky/components/dropzone</a></li>
            
                <li><a href="../modules/husky_components_label.html">husky/components/label</a></li>
            
                <li><a href="../modules/husky_components_overlay.html">husky/components/overlay</a></li>
            
                <li><a href="../modules/husky_components_process.html">husky/components/process</a></li>
            
                <li><a href="../modules/husky_components_toolbar.html">husky/components/toolbar</a></li>
            
                <li><a href="../modules/husky_extensions.html">husky/extensions</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: /Users/marcelmoosbrugger/Development/husky-base/src/components/core/datagrid/decorators/table-view.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @class TableView (Datagrid Decorator)
 * @constructor
 *
 * @param {Object} [viewOptions] Configuration object
 * @param {Boolean} [options.editable] will not set class is-selectable to prevent hover effect for complete rows
 * @param {String} [options.className] additional classname for the wrapping div
 * @param {Boolean} [options.removeRow] displays in the last column an icon to remove a row
 * @param {Object} [options.selectItem] Configuration object of select item (column)
 * @param {String} [options.selectItem.type] Type of select [checkbox, radio]
 * @param {String} [options.selectItem.width] Width of select column
 * @param {Boolean} [options.validation] enables validation for datagrid
 * @param {Boolean} [options.validationDebug] enables validation debug for datagrid
 * @param {Boolean} [options.addRowTop] adds row to the top of the table when add row is triggered
 * @param {Boolean} [options.startTabIndex] start index for tabindex
 * @param {String} [options.columnMinWidth] sets the minimal width of table columns
 * @param {String|Object} [options.contentContainer] the container which holds the datagrid; this options resizes the contentContainer for responsiveness
 * @param {String} [options.fullWidth] If true datagrid style will be full-width mode
 * @param {Array} [options.excludeFields=[&#x27;id&#x27;]] array of fields to exclude by the view
 *
 *
 * @param {Boolean} [rendered] property used by the datagrid-main class
 * @param {Function} [initialize] function which gets called once at the start of the view
 * @param {Function} [render] function to render data
 * @param {Function} [destroy] function to destroy the view and unbind events
 * @param {Function} [onResize] function which gets automatically executed on window resize
 * @param {Function} [unbindCustomEvents] function to unbind the custom events of this object
 */
define(function() {

    &#x27;use strict&#x27;;

    var defaults = {
            editable: false,
            className: &#x27;datagridcontainer&#x27;,
            fullWidth: false,
            contentContainer: null,
            removeRow: false,
            selectItem: {
                type: &#x27;checkbox&#x27;,      // checkbox, radio button
                width: &#x27;50px&#x27;    // numerous value
            },
            validation: false, // TODO does not work for added rows
            validationDebug: false,
            addRowTop: true,
            startTabIndex: 99999,
            excludeFields: [&#x27;&#x27;],
            columnMinWidth: &#x27;70px&#x27;,
            thumbnailFormat: &#x27;50x50&#x27;
        },

        constants = {
            viewClass: &#x27;table-container&#x27;,
            fullWidthClass: &#x27;fullwidth&#x27;,
            // if datagrid is in fullwidth-mode (options.fullWidth is true)
            // this number gets subracted from the tables final width in the resize listener
            overflowIconSpacing: 30,
            ascClass: &#x27;fa-caret-up&#x27;,
            descClass: &#x27;fa-caret-down&#x27;,
            additionalHeaderClasses: &#x27; m-left-5 small-font&#x27;,
            rowRemoverClass: &#x27;row-remover&#x27;,
            editableClass: &#x27;editable&#x27;,
            selectAllName: &#x27;select-all&#x27;,
            isSelectedClass: &#x27;is-selected&#x27;,
            isSelectableClass: &#x27;is-selectable&#x27;,
            sortableClass: &#x27;is-sortable&#x27;,
            tableClass: &#x27;table&#x27;,
            serverValidationError: &#x27;server-validation-error&#x27;,
            oversizedClass: &#x27;oversized&#x27;,
            overflowClass: &#x27;overflow&#x27;,
            thumbSrcKey: &#x27;url&#x27;,
            thumbAltKey: &#x27;alt&#x27;
        },

        /**
         * Templates used by this class
         */
        templates = {
            removeRow: [
                &#x27;&lt;td class=&quot;remove-row&quot;&gt;&#x27;,
                    &#x27;&lt;span class=&quot;fa-trash-o pointer &#x27;+ constants.rowRemoverClass +&#x27;&quot;&gt;&lt;/span&gt;&#x27;,
                &#x27;&lt;/td&gt;&#x27;
            ].join(&#x27;&#x27;),

            checkbox: [
                &#x27;&lt;div class=&quot;custom-checkbox&quot;&gt;&#x27;,
                    &#x27;&lt;input id=&quot;&lt;%= id %&gt;&quot; type=&quot;checkbox&quot; data-form=&quot;false&quot;&lt;% if (!!checked) { %&gt; checked&lt;% } %&gt;/&gt;&#x27;,
                    &#x27;&lt;span class=&quot;icon&quot;&gt;&lt;/span&gt;&#x27;,
                &#x27;&lt;/div&gt;&#x27;
            ].join(&#x27;&#x27;),

            checkboxCell: [
                &#x27;&lt;td&gt;&#x27;,
                    &#x27;&lt;%= checkbox %&gt;&#x27;,
                &#x27;&lt;/td&gt;&#x27;
            ].join(&#x27;&#x27;),

            radio: [
                &#x27;&lt;td&gt;&#x27;,
                    &#x27;&lt;div class=&quot;custom-radio&quot;&gt;&#x27;,
                        &#x27;&lt;input name=&quot;&lt;%= name %&gt;&quot; type=&quot;radio&quot;/&gt;&#x27;,
                        &#x27;&lt;span class=&quot;icon&quot;&gt;&lt;/span&gt;&#x27;,
                    &#x27;&lt;/div&gt;&#x27;,
                &#x27;&lt;/td&gt;&#x27;
            ].join(&#x27;&#x27;)
    },

    /**
     * raised when clicked on an item
     * @event husky.datagrid.item.click
     * @param {String} id of item that was clicked
     */
        ITEM_CLICK = function () {
        return this.datagrid.createEventName.call(this.datagrid, &#x27;item.click&#x27;);
    },

        /**
         * used to update the table width and its containers due to responsiveness
         * @event husky.datagrid.update.table
         */
            UPDATE_TABLE = function () {
            return this.datagrid.createEventName.call(this.datagrid, &#x27;update.table&#x27;);
        },

        /**
         * calculates the width of a text by creating a tablehead element and measure its width
         * @param text
         * @param classArray
         * @param isSortable
         */
            getTextWidth = function (text, classArray, isSortable) {
            var elWidth, el,
                sortIconWidth = 0,
                paddings = 20;
            // handle css classes
            if (!classArray) {
                classArray = [];
            }
            if (isSortable) {
                classArray.push(constants.sortableClass);
                sortIconWidth = 20;
            }
            classArray.push(constants.isSelectedClass);

            el = this.sandbox.dom.createElement(&#x27;&lt;table style=&quot;width:auto&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&quot;&#x27; + classArray.join(&#x27;,&#x27;) + &#x27;&quot;&gt;&#x27; + text + &#x27;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;/table&gt;&#x27;);
            this.sandbox.dom.css(el, {
                &#x27;position&#x27;: &#x27;absolute&#x27;,
                &#x27;visibility&#x27;: &#x27;hidden&#x27;,
                &#x27;height&#x27;: &#x27;auto&#x27;,
                &#x27;width&#x27;: &#x27;auto&#x27;
            });
            this.sandbox.dom.append(&#x27;body&#x27;, el);

            // text width + paddings and sorting icon
            elWidth = this.sandbox.dom.width(el) + paddings + sortIconWidth;

            this.sandbox.dom.remove(el);

            return elWidth;
        };

    return {

        /**
         * Initializes the view, gets called only once
         * @param {Object} context The context of the datagrid class
         * @param {Object} options The options used by the view
         */
        initialize: function(context, options) {
            // store context of the datagrid-component
            this.datagrid = context;

            // make sandbox available in this-context
            this.sandbox = this.datagrid.sandbox;

            // merge defaults with options
            this.options = this.sandbox.util.extend(true, {}, defaults, options);

            this.setVariables();
            this.bindCustomEvents();
        },

        /**
         * Method to render data in table view
         */
        render: function(data, $container) {
            this.data = data;
            this.$el = $container;

            this.$tableContainer = this.sandbox.dom.createElement(&#x27;&lt;div class=&quot;&#x27;+ constants.viewClass +&#x27;&quot;/&gt;&#x27;);
            this.sandbox.dom.append(this.$el, this.$tableContainer);
            this.sandbox.dom.append(this.$tableContainer, this.prepareTable());

            // add full-width class if configured
            if (this.options.fullWidth === true) {
                this.sandbox.dom.addClass(this.$el, constants.fullWidthClass);
            }

            this.bindDomEvents();
            this.onResize();

            // initialize validation
            if (!!this.options.validation) {
                this.sandbox.form.create(this.datagrid.$el);
            }

            this.setHeaderClasses();

            this.rendered = true;
        },

        /**
         * Destroys the view
         */
        destroy: function() {
            this.unbindDomEvents();
            this.sandbox.stop(this.sandbox.dom.find(&#x27;*&#x27;, this.$tableContainer));
            // remove full-width class if configured
            if (this.options.fullWidth === true) {
                this.sandbox.dom.removeClass(this.$el, constants.fullWidthClass);
            }
            this.sandbox.dom.remove(this.$tableContainer);
        },

        /**
         * Binds custom events to the datagrid related to this
         * view (like an extension)
         */
        bindCustomEvents: function() {
            // checks table widths
            this.sandbox.on(UPDATE_TABLE.call(this), this.onResize.bind(this));
        },

        /**
         * Unbinds the custom-events by this view
         */
        unBindCustomEvents: function() {
            this.sandbox.off(UPDATE_TABLE.call(this));
        },

        /**
         * Unbinds the Dom-Events of the view
         */
        unbindDomEvents: function() {
            this.sandbox.dom.unbind(this.sandbox.dom.find(&#x27;*&#x27;, this.$tableContainer));
            this.sandbox.dom.unbind(this.$tableContainer);
        },

        /**
         * Binds Dom related events for this table-view
         */
        bindDomEvents: function() {
            // select events for checkboxes and radio buttons
            if (!!this.options.selectItem.type) {
                this.sandbox.dom.on(
                    this.sandbox.dom.find(&#x27;input[type=&quot;checkbox&quot;], input[type=&quot;radio&quot;]&#x27;, this.$tableContainer),
                    &#x27;click&#x27;,
                    this.selectItem.bind(this)
                );
                //select all event
                this.sandbox.dom.on(
                    this.sandbox.dom.find(&#x27;#&#x27; + constants.selectAllName, this.$tableContainer),
                    &#x27;click&#x27;,
                    this.selectAllItems.bind(this)
                );
            }

            // events for removing row
            if (this.options.removeRow) {
                this.sandbox.dom.on(
                    this.$tableContainer, &#x27;click&#x27;, this.prepareRemoveRow.bind(this), &#x27;.&#x27; + constants.rowRemoverClass
                );
            }

            // emits an event when a table row gets clicked
            this.sandbox.dom.on(
                this.$tableContainer, &#x27;click&#x27;,
                this.emitRowClickedEvent.bind(this), &#x27;tr&#x27;
            );

            // add editable events if configured
            if (!!this.options.editable) {
                this.sandbox.dom.on(
                    this.$tableContainer, &#x27;click&#x27;, this.editCellValues.bind(this), &#x27;.&#x27; + constants.editableClass
                );
                this.sandbox.dom.on(this.$tableContainer, &#x27;click&#x27;, this.focusOnRow.bind(this), &#x27;tr&#x27;);

                // save on &quot;blur&quot;
                this.sandbox.dom.on(window, &#x27;click&#x27;, function() {
                    if (!!this.lastFocusedRow) {
                        this.prepareSave();
                    }
                }.bind(this));
            }

            // add sortable events if configured
            if (this.datagrid.options.sortable) {
                this.sandbox.dom.on(
                    this.sandbox.dom.find(&#x27;thead th[data-attribute]&#x27;, this.$tableContainer),
                    &#x27;click&#x27;,
                    this.prepareSort.bind(this)
                );
            }
        },

        /**
         * Emits the row-clicked event
         */
        emitRowClickedEvent: function(event) {
            var id = this.sandbox.dom.$(event.currentTarget).data(&#x27;id&#x27;);
            if (!!id) {
                this.sandbox.emit(ITEM_CLICK.call(this), id);
            } else {
                this.sandbox.emit(ITEM_CLICK.call(this), event);
            }
        },

        /**
         * Sets the components starting properties
         */
        setVariables: function() {
            this.rendered = false;
            this.$tableContainer = null;
            this.$table = null;
            this.$el = null;
            this.data = null;
            this.rowId = 0;
            this.rowStructure = [];
            this.errorInRow = [];
            this.bottomTabIndex = this.options.startTabIndex || 49999;
            this.topTabIndex = this.options.startTabIndex || 50000;

            // initialize variables for needed for responsivness
            if (!!this.options.contentContainer) {
                if (this.sandbox.dom.css(this.options.contentContainer, &#x27;max-width&#x27;) === &#x27;none&#x27;) {
                    this.originalMaxWidth = null;
                } else {
                    this.originalMaxWidth = this.datagrid.getNumberAndUnit(this.sandbox.dom.css(this.options.contentContainer, &#x27;max-width&#x27;)).number;
                }
                this.contentMarginRight = this.datagrid.getNumberAndUnit(this.sandbox.dom.css(this.options.contentContainer, &#x27;margin-right&#x27;)).number;
                this.contentPaddings = this.datagrid.getNumberAndUnit(this.sandbox.dom.css(this.options.contentContainer, &#x27;padding-right&#x27;)).number;
                this.contentPaddings += this.datagrid.getNumberAndUnit(this.sandbox.dom.css(this.options.contentContainer, &#x27;padding-left&#x27;)).number;
            } else {
                this.contentMarginRight = 0;
                this.contentPaddings = 0;
            }
        },

        /**
         * Sets the header classes used for sorting purposes
         * uses this.datagrid.sort
         */
        setHeaderClasses: function() {
            var attribute = this.datagrid.sort.attribute,
                direction = this.datagrid.sort.direction,
                $element = this.sandbox.dom.find(&#x27;thead th[data-attribute=&#x27; + attribute + &#x27;]&#x27;, this.$tableContainer),
                $span = this.sandbox.dom.children($element, &#x27;span&#x27;)[0];

            if (!!attribute) {
                this.sandbox.dom.addClass($element, constants.isSelectedClass);

                if (direction === &#x27;asc&#x27;) {
                    this.sandbox.dom.addClass($span, constants.ascClass + constants.additionalHeaderClasses);
                } else {
                    this.sandbox.dom.addClass($span, constants.descClass + constants.additionalHeaderClasses);
                }
            }
        },

        /**
         * Perapres the structure of the datagrid when element type is table
         * @returns {table} returns table element
         */
        prepareTable: function() {
            var $table, $thead, $tbody, tblClasses;

            this.$table = $table = this.sandbox.dom.createElement(&#x27;&lt;table&#x27; + (!!this.options.validationDebug ? &#x27;data-debug=&quot;true&quot;&#x27; : &#x27;&#x27; ) + &#x27;/&gt;&#x27;);

            if (!!this.data.head || !!this.datagrid.matchings) {
                $thead = this.sandbox.dom.createElement(&#x27;&lt;thead/&gt;&#x27;);
                this.sandbox.dom.append($thead, this.prepareTableHead());
                this.sandbox.dom.append($table, $thead);
            }

            if (!!this.data.embedded) {
                $tbody = this.sandbox.dom.createElement(&#x27;&lt;tbody/&gt;&#x27;);
                this.sandbox.dom.append($tbody, this.prepareTableRows());
                this.sandbox.dom.append($table, $tbody);
            }

            // set html classes
            tblClasses = [];
            tblClasses.push(
                (!!this.options.className &amp;&amp; this.options.className !== constants.tableClass) ? constants.tableClass +
                &#x27; &#x27; + this.options.className : constants.tableClass
            );

            // when list should not have the hover effect for whole rows do not set the is-selectable class
            if (!this.options.editable) {
                tblClasses.push((this.options.selectItem &amp;&amp; this.options.selectItem.type === &#x27;checkbox&#x27;) ? constants.isSelectableClass : &#x27;&#x27;);
            }

            this.sandbox.dom.addClass($table, tblClasses.join(&#x27; &#x27;));

            return $table;
        },

        /**
         * Prepares table head
         * @returns {string} returns table head
         */

        prepareTableHead: function() {
            var tblColumns, tblCellClass, headData, widthValues, checkboxValues, dataAttribute, isSortable,
                tblColumnStyle, minWidth;

            tblColumns = [];
            headData = this.datagrid.matchings || this.data.head;

            // add a checkbox to head row
            if (!!this.options.selectItem &amp;&amp; !!this.options.selectItem.type) {
                // default values
                if (this.options.selectItem.width) {
                    checkboxValues = this.datagrid.getNumberAndUnit(this.options.selectItem.width);
                }
                minWidth = checkboxValues.number + checkboxValues.unit;

                tblColumns.push(
                    &#x27;&lt;th class=&quot;&#x27;+ constants.selectAllName +&#x27;&quot; &#x27;,
                    &#x27;style=&quot;width:&#x27; + minWidth + &#x27;; max-width:&#x27; + minWidth + &#x27;; min-width:&#x27; + minWidth + &#x27;;&quot;&#x27;,
                    &#x27; &gt;&#x27;
                );

                if (this.options.selectItem.type === &#x27;checkbox&#x27;) {
                    tblColumns.push(this.sandbox.util.template(templates.checkbox)({
                        id: constants.selectAllName,
                        checked: false
                    }));
                }

                tblColumns.push(&#x27;&lt;/th&gt;&#x27;);
            }

            this.rowStructure = [];

            // value used for correct tabindex when row added at top of table
            this.tabIndexParam = 1;

            this.sandbox.util.foreach(headData, function(column) {
                if (this.options.excludeFields.indexOf(column.attribute) &lt; 0) {
                    isSortable = false;

                    if (!!this.datagrid.data.links &amp;&amp; !!this.data.links.sortable) {
                        //is column sortable - check with received sort-links
                        this.sandbox.util.each(this.data.links.sortable, function(value, index) {
                            if (index === column.attribute) {
                                isSortable = true;
                                return false;
                            }
                        }.bind(this));
                    }

                    // calculate width
                    tblColumnStyle = [];
                    if (column.width) {
                        minWidth = column.width;
                    } else if (column.minWidth) {
                        minWidth = column.minWidth;
                    } else {
                        minWidth = getTextWidth.call(this, column.content, [], isSortable);
                        minWidth = (minWidth &gt; this.datagrid.getNumberAndUnit(this.options.columnMinWidth).number) ? minWidth + &#x27;px&#x27; : this.options.columnMinWidth;

                    }
                    tblColumnStyle.push(&#x27;min-width:&#x27; + minWidth);
                    column.minWidth = minWidth;

                    // get width and measureunit
                    if (!!column.width) {
                        widthValues = this.datagrid.getNumberAndUnit(column.width);
                        tblColumnStyle.push(&#x27;max-width:&#x27; + widthValues.number + widthValues.unit);
                        tblColumnStyle.push(&#x27;width:&#x27; + widthValues.number + widthValues.unit);
                    }

                    // add to row structure when valid entry
                    if (column.attribute !== undefined) {
                        this.rowStructure.push({
                            attribute: column.attribute,
                            editable: column.editable,
                            validation: column.validation,
                            type: column.type
                        });

                        if (!!column.editable) {
                            this.tabIndexParam++;
                        }
                    }


                    // add html to table header cell if sortable
                    if (!!isSortable) {
                        dataAttribute = &#x27; data-attribute=&quot;&#x27; + column.attribute + &#x27;&quot;&#x27;;
                        tblCellClass = ((!!column.class) ? &#x27; class=&quot;&#x27; + column.class + &#x27; &quot;&#x27; + constants.sortableClass : &#x27; class=&quot;&#x27;+ constants.sortableClass +&#x27;&quot;&#x27;);
                        tblColumns.push(&#x27;&lt;th&#x27; + tblCellClass + &#x27; style=&quot;&#x27; + tblColumnStyle.join(&#x27;;&#x27;) + &#x27;&quot; &#x27; + dataAttribute + &#x27;&gt;&#x27; + column.content + &#x27;&lt;span&gt;&lt;/span&gt;&lt;/th&gt;&#x27;);
                    } else {
                        tblCellClass = ((!!column.class) ? &#x27; class=&quot;&#x27; + column.class + &#x27;&quot;&#x27; : &#x27;&#x27;);
                        tblColumns.push(&#x27;&lt;th&#x27; + tblCellClass + &#x27; style=&quot;&#x27; + tblColumnStyle.join(&#x27;;&#x27;) + &#x27;&quot; &gt;&#x27; + column.content + &#x27;&lt;/th&gt;&#x27;);
                    }
                }
            }.bind(this));

            // remove-row entry
            if (!!this.options.removeRow) {
                tblColumns.push(&#x27;&lt;th style=&quot;width:30px;&quot;/&gt;&#x27;);
            }

            return &#x27;&lt;tr&gt;&#x27; + tblColumns.join(&#x27;&#x27;) + &#x27;&lt;/tr&gt;&#x27;;
        },

        /**
         * Itterates over all items and prepares the rows
         * @returns {string} returns a string of all rows
         */
        prepareTableRows: function() {
            var tblRows = [];

            if (!!this.data.embedded) {
                this.data.embedded.forEach(function(row) {
                    tblRows.push(this.prepareTableRow(row, false));
                }.bind(this));
            }

            return tblRows;
        },

        /**
         * Responsible for creating a single table-row
         * @param row {Object} the data for a row
         * @param triggeredByAddRow
         * @returns {*}
         */
        prepareTableRow: function(row, triggeredByAddRow) {
            var $tableRow, radioPrefix, key, i;

            if (!!(this.options.template &amp;&amp; this.options.template.row)) {
                $tableRow = this.sandbox.template.parse(this.options.template.row, row);

            } else {
                this.tblColumns = [];
                this.tblRowAttributes = &#x27; data-dom-id=&quot;dom-&#x27; + this.datagrid.options.instanceName + &#x27;-&#x27; + this.rowId + &#x27;&quot;&#x27;;
                this.rowId++;

                if (!!this.options.className &amp;&amp; this.options.className !== &#x27;&#x27;) {
                    radioPrefix = &#x27;-&#x27; + this.options.className;
                } else {
                    radioPrefix = &#x27;&#x27;;
                }

                // add a checkbox to each row
                if (!!this.options.selectItem.type &amp;&amp; this.options.selectItem.type === &#x27;checkbox&#x27;) {
                    this.tblColumns.push(this.sandbox.util.template(templates.checkboxCell)({
                        checkbox: this.sandbox.util.template(templates.checkbox)({
                            id: &#x27;&#x27;,
                            checked: !!row.selected
                        })
                    }));

                    // add a radio to each row
                } else if (!!this.options.selectItem.type &amp;&amp; this.options.selectItem.type === &#x27;radio&#x27;) {
                    this.tblColumns.push(this.sandbox.util.template(templates.radio)({
                        name: &#x27;husky-radio&#x27; + radioPrefix
                    }));
                }

                // when row structure contains more elements than the id then use the structure to set values
                if (this.rowStructure.length) {

                    if (!!triggeredByAddRow &amp;&amp; !!this.options.addRowTop) {
                        this.bottomTabIndex -= (this.tabIndexParam + 1);
                    }

                    this.sandbox.util.foreach(this.rowStructure, function(key, index) {
                        key.editable = key.editable || false;
                        this.createRowCell(key.attribute, row[key.attribute], key.type, key.editable, key.validation, triggeredByAddRow, index);
                    }.bind(this));

                } else {
                    i = 0;
                    for (key in row) {
                        if (row.hasOwnProperty(key)) {
                            this.createRowCell(key, row[key], null, false, null, triggeredByAddRow, i);
                            i++;
                        }
                    }
                }

                if (!!this.options.removeRow) {
                    this.tblColumns.push(this.sandbox.util.template(templates.removeRow)());
                }

                $tableRow = this.sandbox.dom.createElement(&#x27;&lt;tr&#x27;+ this.tblRowAttributes +&#x27;&gt;&#x27;+ this.tblColumns.join(&#x27;&#x27;) +&#x27;&lt;/tr&gt;&#x27;);

                if (!!row.id) {
                    this.sandbox.dom.data($tableRow, &#x27;id&#x27;, row.id);
                    this.sandbox.dom.attr($tableRow, &#x27;data-id&#x27;, row.id);
                }
            }
            return $tableRow;
        },

        /**
         * Sets the value of row cell and the data-id attribute for the row
         * @param key attribute name
         * @param value attribute value
         * @param type {String} The type of the cell. Used to call a function to manipulate the content
         * @param editable flag whether field is editable or not
         * @param validation information for field
         * @param triggeredByAddRow triggered trough add row
         * @param index
         */
        createRowCell: function(key, value, type, editable, validation, triggeredByAddRow, index) {
            var tblCellClasses,
                tblCellContent,
                tblCellStyle,
                tblCellClass,
                k,
                validationAttr = &#x27;&#x27;;

            if (!value) {
                value = &#x27;&#x27;;
            }

            if (this.options.excludeFields.indexOf(key) &lt; 0) {
                tblCellClasses = [];
                tblCellContent = value;

                // prepare table cell classes
                !!value.class &amp;&amp; tblCellClasses.push(value.class);
                (type === this.datagrid.types.THUMBNAILS) &amp;&amp; tblCellClasses.push(&#x27;thumb&#x27;);

                tblCellClass = (!!tblCellClasses.length) ? &#x27;class=&quot;&#x27; + tblCellClasses.join(&#x27; &#x27;) + &#x27;&quot;&#x27; : &#x27;&#x27;;

                if (!!this.options.validation &amp;&amp; !!validation) {
                    for (k in validation) {
                        validationAttr += [&#x27;data-validation-&#x27;, k, &#x27;=&quot;&#x27;, validation[k], &#x27;&quot; &#x27;].join(&#x27;&#x27;);
                    }
                }
                tblCellStyle = &#x27;style=&quot;max-width:&#x27; + this.datagrid.matchings[index].minWidth + &#x27;&quot;&#x27;;

                // call the type manipulate to manipulate the content of the cell
                if (!!type) {
                    if (type === this.datagrid.types.THUMBNAILS) {
                        tblCellContent = this.datagrid.manipulateContent(tblCellContent, type, this.options.thumbnailFormat);
                        tblCellContent = &#x27;&lt;img alt=&quot;&#x27;+ tblCellContent[constants.thumbAltKey] +&#x27;&quot; src=&quot;&#x27;+ tblCellContent[constants.thumbSrcKey] +&#x27;&quot;/&gt;&#x27;;
                    } else {
                        tblCellContent = this.datagrid.manipulateContent(tblCellContent, type);
                    }
                }

                if (!!editable) {
                    if (!!triggeredByAddRow) {
                        // differentiate for tab index
                        if (!!this.options.addRowTop) {
                            this.tblColumns.push(&#x27;&lt;td data-field=&quot;&#x27; + key + &#x27;&quot; &#x27; + tblCellClass + &#x27; &gt;&lt;span class=&quot;&#x27;+ constants.editableClass +&#x27;&quot; style=&quot;display: none&quot;&gt;&#x27; + tblCellContent + &#x27;&lt;/span&gt;&lt;input type=&quot;text&quot; class=&quot;form-element editable-content&quot; tabindex=&quot;&#x27; + this.bottomTabIndex + &#x27;&quot; value=&quot;&#x27; + tblCellContent + &#x27;&quot;  &#x27; + validationAttr + &#x27;/&gt;&lt;/td&gt;&#x27;);
                            this.bottomTabIndex++;
                        } else {
                            this.tblColumns.push(&#x27;&lt;td data-field=&quot;&#x27; + key + &#x27;&quot; &#x27; + tblCellClass + &#x27; &gt;&lt;span class=&quot;&#x27;+ constants.editableClass +&#x27;&quot; style=&quot;display: none&quot;&gt;&#x27; + tblCellContent + &#x27;&lt;/span&gt;&lt;input type=&quot;text&quot; class=&quot;form-element editable-content&quot; tabindex=&quot;&#x27; + this.topTabIndex + &#x27;&quot; value=&quot;&#x27; + tblCellContent + &#x27;&quot;  &#x27; + validationAttr + &#x27;/&gt;&lt;/td&gt;&#x27;);
                            this.topTabIndex++;
                        }
                    } else {
                        this.tblColumns.push(&#x27;&lt;td data-field=&quot;&#x27; + key + &#x27;&quot; &#x27; + tblCellClass + &#x27; &gt;&lt;span class=&quot;&#x27;+ constants.editableClass +&#x27;&quot;&gt;&#x27; + tblCellContent + &#x27;&lt;/span&gt;&lt;input type=&quot;text&quot; class=&quot;form-element editable-content hidden&quot; value=&quot;&#x27; + tblCellContent + &#x27;&quot; tabindex=&quot;&#x27; + this.topTabIndex + &#x27;&quot; &#x27; + validationAttr + &#x27;/&gt;&lt;/td&gt;&#x27;);
                        this.topTabIndex++;

                    }
                } else {
                    this.tblColumns.push(&#x27;&lt;td data-field=&quot;&#x27; + key + &#x27;&quot; &#x27; + tblCellClass + &#x27; &#x27; + tblCellStyle + &#x27;&gt;&#x27; + tblCellContent + &#x27;&lt;/td&gt;&#x27;);
                }
            } else {
                this.tblRowAttributes += &#x27; data-&#x27; + key + &#x27;=&quot;&#x27; + value + &#x27;&quot;&#x27;;
            }
        },

        /**
         * Adds a row to the datagrid
         * @param row
         */
        addRecord: function(row) {
            var $row, $firstInputField, $checkbox;
            // check for other element types when implemented
            $row = this.sandbox.dom.$(this.prepareTableRow(row, true));

            // when unsaved new row exists - save it
            this.prepareSave();

            // prepend or append row
            if (!!this.options.addRowTop) {
                this.sandbox.dom.prepend(this.$table, $row);
            } else {
                this.sandbox.dom.append(this.$table, $row);
            }

            $firstInputField = this.sandbox.dom.find(&#x27;input[type=text]&#x27;, $row)[0];
            this.sandbox.dom.focus($firstInputField);

            if (!!this.options.editable) {
                this.lastFocusedRow = this.getInputValuesOfRow($row);
            }

            // if allchecked then disable top checkbox after adding new row
            if (!!this.options.selectItem.type &amp;&amp; this.options.selectItem.type === &#x27;checkbox&#x27;) {
                $checkbox = this.sandbox.dom.find(&#x27;#&#x27; + constants.selectAllName, this.$tableContainer);
                if (this.sandbox.dom.hasClass($checkbox, constants.isSelectedClass)) {
                    this.sandbox.dom.prop($checkbox, &#x27;checked&#x27;, false);
                    this.sandbox.dom.removeClass($checkbox, constants.isSelectedClass);
                }
            }
        },

        /**
         * Perparse to save new/changed data includes validation
         */
        prepareSave: function() {
            if (!!this.lastFocusedRow) {

                var $tr = this.sandbox.dom.find(&#x27;tr[data-dom-id=&#x27; + this.lastFocusedRow.domId + &#x27;]&#x27;, this.$tableContainer),
                    lastFocusedRowCurrentData = this.getInputValuesOfRow($tr),

                    data = {},
                    key,
                    url,
                    isValid = true,
                    valuesChanged = false,
                    isDataEmpty;

                data.id = lastFocusedRowCurrentData.id;

                // validate locally
                if (!!this.options.validation &amp;&amp; !this.sandbox.form.validate(&#x27;#&#x27; + this.datagrid.elId)) {
                    isValid = false;
                }

                isDataEmpty = this.isDataRowEmpty(lastFocusedRowCurrentData.fields);

                // do nothing when data is not valid or no data exists
                if (!!isValid &amp;&amp; !isDataEmpty) {

                    // check which values changed and remember these
                    for (key in lastFocusedRowCurrentData.fields) {
                        if (this.lastFocusedRow.fields.hasOwnProperty(key) &amp;&amp; this.lastFocusedRow.fields[key] !== lastFocusedRowCurrentData.fields[key]) {
                            data[key] = lastFocusedRowCurrentData.fields[key];
                            valuesChanged = true;
                        }
                    }

                    // trigger save action when data changed
                    if (!!valuesChanged || true) {
                        url = this.datagrid.getUrlWithoutParams();

                        // pass data to datagrid to save it
                        this.datagrid.saveGrid.call(this.datagrid, data, url,
                            this.saveSuccess.bind(this, this.lastFocusedRow.domId, $tr),
                            this.saveFail.bind(this, this.lastFocusedRow.domId, $tr),
                            this.options.addRowTop);

                        // reset last focused row after save
                        this.lastFocusedRow = null;

                    } else if (this.errorInRow.indexOf(this.lastFocusedRow.domId) !== -1) {
                        this.sandbox.logger.log(&quot;Error in table row!&quot;);

                    } else {
                        // nothing changed - reset immediately
                        this.sandbox.logger.log(&quot;No data changed!&quot;);
                        this.resetRowInputFields($tr);
                        this.unlockWidthsOfColumns(this.sandbox.dom.find(&#x27;table th&#x27;, this.$el));
                    }

                } else {
                    this.sandbox.logger.log(&quot;There seems to be some invalid or empty data!&quot;);
                }

            }
        },

        /**
         * Checks wether data is in row or not
         * @param data fields object
         */
        isDataRowEmpty: function(data) {
            var isEmpty = true, field;

            for (field in data) {
                if (data[field] !== &#x27;&#x27;) {
                    isEmpty = false;
                    break;
                }
            }

            return isEmpty;
        },

        /**
         * Callback for save success
         * @param $tr
         * @param domId
         * @param data
         */
        saveSuccess: function(domId, $tr, data) {
            // remove row from error list
            if (this.errorInRow.indexOf(domId) !== -1) {
                this.errorInRow.splice(this.errorInRow.indexOf(domId), 1);
            }

            this.resetRowInputFields($tr);
            this.unlockWidthsOfColumns(this.sandbox.dom.find(&#x27;table th&#x27;, this.$el));

            // set new returned data
            this.setDataForRow($tr[0], data);
        },

        /**
         * Callback for save fail
         * @param domId
         * @param $tr
         * @param jqXHR
         */
        saveFail: function(domId, $tr, jqXHR) {
            var message = JSON.parse(jqXHR.responseText);

            // remember row with error
            if (this.errorInRow.indexOf(domId) === -1) {
                this.errorInRow.push(domId);
            }
            // error in context with database constraints
            if (!!message.field) {
                this.showValidationError($tr, message.field);
            }
        },

        /**
         *  Hides input fields and displays new content for table row
         * @param $tr
         */
        resetRowInputFields: function($tr) {
            var $inputFields = this.sandbox.dom.find(&#x27;input[type=text]:not(.hidden)&#x27;, $tr),
                content, $span;

            this.sandbox.util.each($inputFields, function($field, index) {

                // remove css class for server side validation error
                // TODO: remove this when server-validation validation type is implemented
                if (this.sandbox.dom.hasClass($field, constants.serverValidationError)) {
                    this.sandbox.dom.removeClass($field, constants.serverValidationError);
                }

                content = this.sandbox.dom.val(this.sandbox.dom.$($field));
                $span = this.sandbox.dom.prev($field, &#x27;.&#x27; + constants.editableClass);
                $span.text(content);

                this.sandbox.dom.addClass($field, &#x27;hidden&#x27;);
                this.sandbox.dom.show($span);

            }.bind(this));
        },

        /**
         * Resets the min-width of columns and
         * @param $th array of th elements
         */
        unlockWidthsOfColumns: function($th) {
            if (!!this.columnWidths) {
                this.sandbox.util.each($th, function($el, index) {
                    // skip columns without data-attribute because the have min/max and normal widths by default
                    if (!!this.sandbox.dom.data($el, &#x27;attribute&#x27;)) {
                        this.sandbox.dom.css($el, &#x27;min-width&#x27;, this.columnWidths[index]);
                        this.sandbox.dom.css($el, &#x27;max-width&#x27;, &#x27;&#x27;);
                        this.sandbox.dom.css($el, &#x27;width&#x27;, &#x27;&#x27;);
                    }
                }.bind(this));
            }
        },

        /**
         * Makes the widths of columns fixed when the table is in edit mode
         * prevents changes in column width
         * @param $th array of th elements
         */
        lockWidthsOfColumns: function($th) {
            var width, minwidth;
            this.columnWidths = [];

            this.sandbox.util.each($th, function($el, index) {
                minwidth = this.sandbox.dom.css($el, &#x27;min-width&#x27;);
                this.columnWidths.push(minwidth);

                width = this.sandbox.dom.outerWidth($el);
                this.sandbox.dom.css($el, &#x27;min-width&#x27;, width);
                this.sandbox.dom.css($el, &#x27;max-width&#x27;, width);
                this.sandbox.dom.css($el, &#x27;width&#x27;, width);
            }.bind(this));
        },

        /**
         * Sets the data for a row
         * @param $tr dom row
         * @param data
         */
        setDataForRow: function($tr, data) {
            var editables, field, $input;

            // set id
            this.sandbox.dom.data($tr, &#x27;id&#x27;, data.id);
            this.sandbox.dom.attr($tr, &#x27;data-id&#x27;, data.id);

            this.sandbox.util.each(this.sandbox.dom.find(&#x27;td&#x27;, $tr), function($el, index) {

                editables = this.sandbox.dom.find(&#x27;.&#x27; + constants.editableClass, $el);
                field = this.sandbox.dom.data($el, &#x27;field&#x27;);
                $input = this.sandbox.dom.find(&#x27;input[type=text]&#x27;, $el);

                if (!!field) {
                    if (!!editables &amp;&amp; editables.length === 1) { // set values in spans
                        this.sandbox.dom.html(editables[0], data[field]);
                        this.sandbox.dom.val($input, data[field]);
                    } else { // set values in td
                        this.sandbox.dom.html($el, data[field]);
                    }
                }

            }.bind(this));
        },

        /**
         * Sets the validation error class for a dom element
         * @param $domElement
         * @param field name of field which caused the error
         */
        showValidationError: function($domElement, field) {
            var $td = this.sandbox.dom.find(&#x27;td[data-field=&#x27; + field + &#x27;]&#x27;, $domElement)[0],
                $input = this.sandbox.dom.find(&#x27;input&#x27;, $td)[0];

            if (this.sandbox.dom.hasClass($td, &#x27;husky-validate-success&#x27;)) {
                this.sandbox.dom.removeClass($td, &#x27;husky-validate-success&#x27;);
            }

            this.sandbox.dom.addClass($td, &#x27;husky-validate-error&#x27;);

            // add class for serverside validation error
            // TODO remove this when correct validation type is implmented
            if (!this.sandbox.dom.hasClass($input, constants.serverValidationError)) {
                this.sandbox.dom.addClass($input, constants.serverValidationError);
            }
        },

        /**
         * Returns an object with the current values of the inputfields, id and domId
         * @param $tr table row
         * @returns {{domId: *, id: *, fields: Array}}
         */
        getInputValuesOfRow: function($tr) {
            var id = this.sandbox.dom.data($tr, &#x27;id&#x27;),
                domId = this.sandbox.dom.data($tr, &#x27;dom-id&#x27;),
                $inputs = this.sandbox.dom.find(&#x27;input[type=text]&#x27;, $tr),
                fields = [], field, $td;

            this.sandbox.util.each($inputs, function($input, index) {
                $td = this.sandbox.dom.parent($input, &#x27;td&#x27;);
                field = this.sandbox.dom.data($td, &#x27;field&#x27;);

                fields[field] = $input.value;

            }.bind(this));
            return {
                domId: domId,
                id: id,
                fields: fields
            };

        },

        /**
         * Prepares for removing a row
         * Raises the husky.datagrid.record.remove-click event when auto remove handling is not set to true
         * @param event
         */
        prepareRemoveRow: function(event) {
            this.sandbox.dom.stopPropagation(event);
            this.removeRecord(event);
        },

        /**
         * Removes a row from the datagrid
         * @param event
         */
        removeRecord: function(event) {
            var $element, $tblRow, id, $editableElements, $checkboxes;

            if (typeof event === &#x27;object&#x27;) {
                $element = this.sandbox.dom.$(event.currentTarget);
                $tblRow = this.sandbox.dom.closest($element, &#x27;tr&#x27;)[0];
                id = this.sandbox.dom.data($tblRow, &#x27;id&#x27;);
            } else {
                id = event;
                $tblRow = this.sandbox.dom.find(&#x27;tr[data-id=&quot;&#x27; + id + &#x27;&quot;]&#x27;)[0];
            }

            // remove row elements from validation
            if (!!this.options.validation) {
                $editableElements = this.sandbox.dom.find(&#x27;.&#x27; + constants.editableClass, $tblRow);
                this.sandbox.util.each($editableElements, function($element, index) {
                    this.sandbox.form.removeField(&#x27;#&#x27; + this.datagrid.elId, $element);
                }.bind(this));
            }

            if (!!id) {
                this.datagrid.removeRecord.call(this.datagrid, id);
            }
            this.sandbox.dom.remove($tblRow);

            // when last table row was removed, uncheck thead checkbox if exists
            $checkboxes = this.sandbox.dom.find(&#x27;input[type=checkbox]&#x27;, this.$el);
            if ($checkboxes.length === 1) {
                this.sandbox.dom.removeClass(constants.isSelectedClass, $checkboxes[0]);
                this.sandbox.dom.prop($checkboxes[0], &#x27;checked&#x27;, false);
            }

        },

        /**
         * Gets automatically executed on window resize
         * responsible for the responsiveness
         */
        onResize: function() {
            var finalWidth,
                contentPaddings = 0,
                content = !!this.options.contentContainer ? this.options.contentContainer : this.$el,
                tableWidth = this.sandbox.dom.width(this.$table),
                tableOffset = this.sandbox.dom.offset(this.$table),
                contentWidth = this.sandbox.dom.width(content),
                windowWidth = this.sandbox.dom.width(this.sandbox.dom.window),
                overlaps = false,
                originalMaxWidth = contentWidth;

            tableOffset.right = tableOffset.left + tableWidth;


            if (!!this.options.contentContainer &amp;&amp; !!this.originalMaxWidth) {
                // get original max-width and right margin
                originalMaxWidth = this.originalMaxWidth;
                contentPaddings = this.contentPaddings;
            }

            // if table is greater than max content width
            if (tableWidth &gt; originalMaxWidth - contentPaddings &amp;&amp; contentWidth &lt; windowWidth - tableOffset.left) {
                // adding this class, forces table cells to shorten long words
                this.sandbox.dom.addClass(this.$el, constants.oversizedClass);
                overlaps = true;
                // reset table width and offset
                tableWidth = this.sandbox.dom.width(this.$table);
                tableOffset.right = tableOffset.left + tableWidth;
            }

            // tablecontainer should have width of table in normal cases
            finalWidth = tableWidth;

            // if table &gt; window-size set width to available space
            if (tableOffset.right + this.contentMarginRight &gt; windowWidth) {
                finalWidth = windowWidth - tableOffset.left;
            } else {
                // set scroll position back
                this.sandbox.dom.scrollLeft(this.$el, 0);
            }

            // width is not allowed to be smaller than the width of content
            if (finalWidth &lt; contentWidth) {
                finalWidth = contentWidth;
            }

            // if contentContainer is set, adapt maximum size
            if (!!this.options.contentContainer) {
                this.sandbox.dom.css(this.options.contentContainer, &#x27;max-width&#x27;, finalWidth + contentPaddings);
                finalWidth = this.sandbox.dom.width(this.options.contentContainer);
                if (!overlaps) {
                    // if table does not overlap border, set content to original width
                    this.sandbox.dom.css(this.options.contentContainer, &#x27;max-width&#x27;, &#x27;&#x27;);
                }
            }

            // now set width
            this.sandbox.dom.width(this.$el, finalWidth);

            // check scrollwidth and add class
            if (this.sandbox.dom.get(this.$tableContainer, 0).scrollWidth &gt; finalWidth) {
                this.sandbox.dom.addClass(this.$tableContainer, constants.overflowClass);

                // if overflown and in full width mode reduce list-width
                if (this.options.fullWidth === true) {
                    finalWidth = finalWidth - constants.overflowIconSpacing;
                    this.sandbox.dom.width(this.$el, finalWidth);
                }

            } else {
                this.sandbox.dom.removeClass(this.$tableContainer, constants.overflowClass);
            }
        },

        /**
         * Selectes or deselects the clicked item
         * @param event
         */
        selectItem: function(event) {
            this.sandbox.dom.stopPropagation(event);

            var $element, itemId, parentTr;
            $element = this.sandbox.dom.$(event.currentTarget);

            if (!this.sandbox.dom.is($element, &#x27;input&#x27;)) {
                $element = this.sandbox.dom.find(&#x27;input&#x27;, this.sandbox.dom.parent($element));
            }

            parentTr = this.sandbox.dom.parents($element, &#x27;tr&#x27;);
            itemId = this.sandbox.dom.data(parentTr, &#x27;id&#x27;);

            if (this.sandbox.dom.attr($element, &#x27;type&#x27;) === &#x27;checkbox&#x27;) {
                if (this.sandbox.dom.prop($element, &#x27;checked&#x27;) === false) {
                    this.sandbox.dom.removeClass($element, constants.isSelectedClass);
                    this.sandbox.dom.prop($element, &#x27;checked&#x27;, false);

                    // uncheck &#x27;Select All&#x27;-checkbox
                    this.sandbox.dom.prop(
                        this.sandbox.dom.find(&#x27;#&#x27; + constants.selectAllName, this.$tableContainer),
                        &#x27;checked&#x27;, false
                    );

                    this.datagrid.setItemUnselected.call(this.datagrid, itemId);
                } else {
                    this.sandbox.dom.addClass($element, constants.isSelectedClass);
                    this.sandbox.dom.prop($element, &#x27;checked&#x27;, true);
                    if (!!itemId) {
                        this.datagrid.setItemSelected.call(this.datagrid, itemId);
                    }
                }

            } else if (this.sandbox.dom.attr($element, &#x27;type&#x27;) === &#x27;radio&#x27;) {

                this.datagrid.deselectAllItems.call(this.datagrid);

                this.sandbox.dom.removeClass(
                    this.sandbox.dom.find(&#x27;tr input[type=&quot;radio&quot;]&#x27;, this.$tableContainer), constants.isSelectedClass);
                this.sandbox.dom.prop(
                    this.sandbox.dom.find(&#x27;tr input[type=&quot;radio&quot;]&#x27;, this.$tableContainer), &#x27;checked&#x27;, false);

                this.sandbox.dom.addClass($element, constants.isSelectedClass);
                this.sandbox.dom.prop($element, &#x27;checked&#x27;, true);

                if (!!itemId) {
                    this.datagrid.setItemSelected.call(this.datagrid, itemId);
                }
            }

        },

        /**
         * Shows input and hides span
         * @param event
         */
        editCellValues: function(event) {
            var $target = event.currentTarget,
                $input = this.sandbox.dom.next($target, &#x27;input&#x27;);

            this.lockWidthsOfColumns(this.sandbox.dom.find(&#x27;table th&#x27;, this.$tableContainer));

            this.sandbox.dom.hide($target);
            this.sandbox.dom.removeClass($input, &#x27;hidden&#x27;);
            this.sandbox.dom.select($input[0]);
        },

        /**
         * Put focus on table row and remember values
         */
        focusOnRow: function(event) {
            var $tr = event.currentTarget,
                domId = this.sandbox.dom.data($tr, &#x27;dom-id&#x27;);

            this.sandbox.dom.stopPropagation(event);
            this.sandbox.logger.log(&quot;focus on row&quot;, domId);

            if (!!this.lastFocusedRow &amp;&amp; this.lastFocusedRow.domId !== domId) { // new focus
                this.prepareSave();
                this.lastFocusedRow = this.getInputValuesOfRow($tr);
                this.sandbox.logger.log(&quot;focused &quot; + this.lastFocusedRow.domId + &quot; now!&quot;);
            } else if (!this.lastFocusedRow) { // first focus
                this.lastFocusedRow = this.getInputValuesOfRow($tr);
                this.sandbox.logger.log(&quot;focused &quot; + this.lastFocusedRow.domId + &quot; now!&quot;);
            }
        },

        /**
         * Selects or deselect all available items of the list
         * @param event
         */
        selectAllItems: function(event) {
            this.sandbox.dom.stopPropagation(event);

            var $headCheckbox = this.sandbox.dom.find(&#x27;th input[type=&quot;checkbox&quot;]&#x27;, this.$tableContainer)[0],
                $checkboxes = this.sandbox.dom.find(&#x27;input[type=&quot;checkbox&quot;]&#x27;, this.$tableContainer);

            if (this.sandbox.dom.prop($headCheckbox, &#x27;checked&#x27;) === false) {
                this.sandbox.dom.prop($checkboxes, &#x27;checked&#x27;, false);
                this.sandbox.dom.removeClass($checkboxes, constants.isSelectedClass);
                this.datagrid.deselectAllItems.call(this.datagrid);
            } else {
                this.sandbox.dom.prop($checkboxes, &#x27;checked&#x27;, true);
                this.sandbox.dom.addClass($checkboxes, constants.isSelectedClass);
                this.datagrid.selectAllItems.call(this.datagrid);
            }
        },

        /**
         * Handles the click on a sortable column title
         *
         * Creates the function parameters need for sorting
         * and delegates the sorting itself to the datagrid
         * @param event {Object} the event object
         */
        prepareSort: function(event) {
            var $element = event.currentTarget,
                $span = this.sandbox.dom.children($element, &#x27;span&#x27;)[0],

                attribute = this.sandbox.dom.data($element, &#x27;attribute&#x27;),
                direction = this.sandbox.dom.hasClass($span, constants.ascClass) ? &#x27;desc&#x27; : &#x27;asc&#x27;;

                // delegate sorting to datagrid
                this.datagrid.sortGrid.call(this.datagrid, attribute, direction);
        }
    };
});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
